<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Text Cleaner & Chunker</title>
    <style>
      body {
        font-family: 'Roboto', sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f7f6;
        color: #333;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
        background-color: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #007bff;
        margin-bottom: 30px;
      }
      .input-group {
        margin-bottom: 20px;
      }
      .input-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: #555;
      }
      input[type='number'],
      input[type='text'],
      textarea {
        padding: 10px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 15px;
        width: 100%;
        box-sizing: border-box;
        font-family: 'Roboto', sans-serif;
      }
      textarea {
        min-height: 100px;
        resize: vertical;
      }
      #charCount {
        font-size: 13px;
        text-align: right;
        margin-top: 5px;
        font-weight: bold;
        padding: 3px 8px;
        border-radius: 4px;
        display: inline-block;
        float: right;
      }
      .button-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }
      .action-button {
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s ease;
        flex: 1;
        min-width: 200px;
      }
      .split-button {
        background-color: #28a745;
        color: white;
      }
      .split-button:hover {
        background-color: #218838;
      }
      .paste-button {
        background-color: #6c757d;
        color: white;
      }
      .paste-button:hover {
        background-color: #5a6268;
      }
      #chunkedTextContainer {
        margin-top: 25px;
        border-top: 1px solid #eee;
        padding-top: 20px;
      }
      .chunk-container {
        margin-bottom: 20px;
        background-color: #fcfcfc;
        border: 1px solid #eee;
        border-radius: 4px;
        padding: 15px;
        position: relative;
      }
      .chunk-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .chunk-title {
        font-weight: bold;
        font-size: 16px;
        margin-right: 15px;
      }
      .copy-button {
        padding: 5px 10px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s ease;
        flex-shrink: 0;
      }
      .copy-button:hover {
        background-color: #0056b3;
      }
      .copy-button.copied {
        background-color: #218838;
      }
      .chunk-textarea {
        width: 100%;
        height: 100px;
        padding: 10px;
        font-size: 14px;
        line-height: 1.5;
        border: 1px solid #ddd;
        border-radius: 4px;
        resize: vertical;
        background-color: #fff;
      }
      .trim-options {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }
      .trim-options .input-group {
        flex-grow: 1;
        min-width: 250px;
      }
      .regex-option {
        display: flex;
        align-items: center;
        margin-top: 8px;
        font-size: 14px;
      }
      .regex-option input {
        width: auto;
        margin-right: 8px;
      }
      .status-message {
        padding: 12px 15px;
        border-radius: 4px;
        margin-bottom: 15px;
        text-align: left;
        display: none;
        font-size: 14px;
      }
      .status-success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status-error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      .status-info {
        background-color: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      .status-warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
      }
      .translation-warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
        border-left: 4px solid #ffc107;
        padding: 12px 15px;
        margin-bottom: 15px;
        border-radius: 4px;
        display: none;
        font-size: 14px;
      }
      .translation-warning.visible {
        display: block;
      }
      .translation-warning h3 {
        margin-top: 0;
        margin-bottom: 8px;
        color: #856404;
        font-size: 16px;
      }
      .translation-warning p {
        margin: 5px 0;
      }
      .char-count-container {
        background-color: #f8f9fa;
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 15px;
        border: 1px solid #e9ecef;
      }
      .char-count-container p {
        margin: 5px 0;
        font-size: 14px;
      }
      .char-count-container .highlight {
        font-weight: bold;
        font-size: 16px;
      }
      .char-count-container .good {
        color: #28a745;
      }
      .char-count-container .warning {
        color: #ffc107;
      }
      .char-count-container .danger {
        color: #dc3545;
      }
      .quick-copy-all {
        background-color: #17a2b8;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 15px;
        font-size: 14px;
        transition: background-color 0.2s ease;
      }
      .quick-copy-all:hover {
        background-color: #138496;
      }
      .chunk-indicator {
        position: absolute;
        top: -10px;
        right: 15px;
        background-color: #6c757d;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 12px;
        font-weight: bold;
      }
      .chunk-indicator.safe {
        background-color: #28a745;
      }
      .chunk-indicator.warning {
        background-color: #ffc107;
        color: #212529;
      }
      .chunk-indicator.danger {
        background-color: #dc3545;
      }
      .pattern-presets {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }
      .pattern-preset {
        padding: 8px 15px;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      .pattern-preset:hover {
        background-color: #dee2e6;
      }
      .pattern-preset.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
      }
      .extension-section {
        background-color: #e7f3ff;
        border: 1px solid #b3d7ff;
        border-radius: 4px;
        padding: 15px;
        margin-bottom: 20px;
      }
      .extension-section h3 {
        margin-top: 0;
        color: #0056b3;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Text Cleaner & Chunker</h1>

      <div id="statusMessage" class="status-message"></div>
      
      <div id="translationWarning" class="translation-warning">
        <h3>‚ö†Ô∏è Translation App Limit Alert</h3>
        <p>Your trimmed text is <span id="trimmedCharCount">0</span> characters.</p>
        <p><strong>Good news:</strong> This is less than 4800 characters, so you can copy the entire text below and paste it directly into your translation app!</p>
        <p>No need to split into chunks since it fits within the 5000 character limit.</p>
      </div>

      <div class="extension-section" id="extensionSection" style="display: none;">
        <h3>üöÄ 69shuba Extension Active</h3>
        <p>Text loaded from: <span id="currentChapterUrl"></span></p>
        <button id="nextChapterBtn" class="action-button" style="background-color: #6f42c1; color: white;">
          ‚è≠Ô∏è Go to Next Chapter
        </button>
      </div>

      <div class="input-group">
        <label for="chapterContent">Text Content:</label>
        <textarea
          id="chapterContent"
          placeholder="Paste the chapter text here or use the extension to auto-load from 69shuba..."
        ></textarea>
        <div id="charCount">Total characters: 0</div>
        <div style="clear: both;"></div>
      </div>

      <div class="pattern-presets">
        <div class="pattern-preset active" data-preset="chinese">Chinese Novel Preset</div>
        <div class="pattern-preset" data-preset="custom">Custom Patterns</div>
        <div class="pattern-preset" data-preset="none">No Trimming</div>
      </div>

      <div class="trim-options">
        <div class="input-group">
          <label for="startMarker">Start content at this text/pattern:</label>
          <input type="text" id="startMarker" value="Á¨¨\d+Á´†\[s\S]*" />
          <div class="regex-option">
            <input type="checkbox" id="useStartRegex" checked />
            <label for="useStartRegex">Use RegEx</label>
          </div>
        </div>
        <div class="input-group">
          <label for="endMarker">End content before this text/pattern:</label>
          <input type="text" id="endMarker" value="(Êú¨Á´†ÂÆå)" />
          <div class="regex-option">
            <input type="checkbox" id="useEndRegex" />
            <label for="useEndRegex">Use RegEx</label>
          </div>
        </div>
      </div>

      <div class="input-group">
        <label for="maxChars">Max characters per chunk:</label>
        <input type="number" id="maxChars" value="1800" min="100" max="4800" />
        <small style="color: #666; margin-top: 5px; display: block;">
          Set to 4800 or less for direct translation app copying
        </small>
      </div>

      <div class="button-group">
        <button id="pasteButton" class="action-button paste-button">
          üìã Paste from Clipboard & Auto-Split
        </button>
        <button id="splitButton" class="action-button split-button">
          Clean and Split Text
        </button>
      </div>

      <div id="charCountInfo" class="char-count-container" style="display: none;">
        <!-- Will be populated by JavaScript -->
      </div>

      <div id="chunkedTextContainer"></div>
    </div>

    <script>
      let lastClickedCopyButton = null;
      let lastTrimmedText = '';
      let lastTrimmedLength = 0;
      let currentChapterUrl = '';
      let nextChapterUrl = '';

      // Check if page was opened by extension
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('text') || urlParams.has('url')) {
        document.getElementById('extensionSection').style.display = 'block';
        if (urlParams.has('url')) {
          currentChapterUrl = urlParams.get('url');
          document.getElementById('currentChapterUrl').textContent = currentChapterUrl;
        }
        if (urlParams.has('text')) {
          const text = decodeURIComponent(urlParams.get('text'));
          document.getElementById('chapterContent').value = text;
          updateCharCount();
          setTimeout(chunkText, 500);
        }
      }

      function showStatus(message, type = 'info') {
        const statusEl = document.getElementById('statusMessage');
        statusEl.textContent = message;
        statusEl.className = `status-message status-${type}`;
        statusEl.style.display = 'block';
        
        if (type === 'success') {
          setTimeout(() => {
            statusEl.style.display = 'none';
          }, 4000);
        }
      }

      function hideStatus() {
        document.getElementById('statusMessage').style.display = 'none';
      }

      function updateTranslationWarning(trimmedLength) {
        const warningEl = document.getElementById('translationWarning');
        const charCountEl = document.getElementById('trimmedCharCount');
        
        charCountEl.textContent = trimmedLength;
        
        if (trimmedLength > 0 && trimmedLength < 4800) {
          warningEl.classList.add('visible');
          showStatus(`Perfect! Trimmed text (${trimmedLength} chars) fits in translation app. You can copy entire text below.`, 'success');
        } else {
          warningEl.classList.remove('visible');
        }
        
        lastTrimmedLength = trimmedLength;
      }

      function updateCharCountInfo(originalLength, trimmedLength, chunkCount) {
        const infoEl = document.getElementById('charCountInfo');
        
        if (originalLength === 0) {
          infoEl.style.display = 'none';
          return;
        }
        
        const charsRemoved = originalLength - trimmedLength;
        const removalPercent = originalLength > 0 ? Math.round((charsRemoved / originalLength) * 100) : 0;
        
        let statusClass = 'good';
        let statusText = 'Perfect for translation app';
        
        if (trimmedLength > 5000) {
          statusClass = 'danger';
          statusText = 'Too long for translation app (needs splitting)';
        } else if (trimmedLength > 4800) {
          statusClass = 'warning';
          statusText = 'Close to translation app limit (5000 chars)';
        } else if (trimmedLength === 0) {
          statusText = 'No text after trimming';
        }
        
        infoEl.innerHTML = `
          <p><strong>Character Count Analysis:</strong></p>
          <p>Original text: ${originalLength.toLocaleString()} characters</p>
          <p>After trimming: <span class="highlight ${statusClass}">${trimmedLength.toLocaleString()} characters</span></p>
          <p>Removed by trimming: ${charsRemoved.toLocaleString()} characters (${removalPercent}%)</p>
          <p>Status: <span class="${statusClass}">${statusText}</span></p>
          ${chunkCount > 0 ? `<p>Split into: ${chunkCount} chunk(s)</p>` : ''}
        `;
        
        infoEl.style.display = 'block';
      }

      async function pasteFromClipboard() {
        try {
          const text = await navigator.clipboard.readText();
          if (!text.trim()) {
            showStatus('Clipboard is empty or contains no text', 'error');
            return;
          }
          
          const chapterContentEl = document.getElementById('chapterContent');
          chapterContentEl.value = text;
          updateCharCount();
          showStatus('Text pasted from clipboard successfully!', 'success');
          
          setTimeout(() => {
            chunkText();
          }, 300);
          
        } catch (error) {
          console.error('Failed to read clipboard:', error);
          showStatus('Failed to access clipboard. Please paste manually into the text area.', 'error');
        }
      }

      function copyToClipboard(text, button) {
        navigator.clipboard.writeText(text).then(() => {
          if (lastClickedCopyButton && lastClickedCopyButton !== button) {
            lastClickedCopyButton.classList.remove('copied');
            lastClickedCopyButton.textContent = 'Copy';
          }
          
          button.textContent = 'Copied! ‚úî';
          button.classList.add('copied');
          lastClickedCopyButton = button;
          showStatus('Chunk copied to clipboard!', 'success');
          
        }).catch(err => {
          console.error('Failed to copy text:', err);
          showStatus('Failed to copy text to clipboard', 'error');
        });
      }

      function copyAllChunks() {
        const chunks = [];
        const textareas = document.querySelectorAll('.chunk-textarea');
        
        textareas.forEach((textarea, index) => {
          chunks.push(`--- Part ${index + 1} of ${textareas.length} ---\n${textarea.value}\n`);
        });
        
        const allText = chunks.join('\n');
        navigator.clipboard.writeText(allText).then(() => {
          showStatus('All chunks copied to clipboard!', 'success');
        }).catch(err => {
          console.error('Failed to copy all chunks:', err);
          showStatus('Failed to copy all chunks', 'error');
        });
      }

      function trimText(text, startMarker, useStartRegex, endMarker, useEndRegex) {
        let processedText = text;
        const originalLength = text.length;
        
        if (startMarker) {
          let startIndex = -1;
          if (useStartRegex) {
            try {
              const regex = new RegExp(startMarker, 's');
              const match = regex.exec(processedText);
              if (match) {
                startIndex = match.index;
              }
            } catch (e) {
              showStatus(`Invalid Start RegEx: ${e.message}`, 'error');
              throw e;
            }
          } else {
            startIndex = processedText.indexOf(startMarker);
          }
          if (startIndex !== -1) {
            processedText = processedText.substring(startIndex);
          }
        }

        if (endMarker) {
          let endIndex = -1;
          if (useEndRegex) {
            try {
              const regex = new RegExp(endMarker);
              const match = regex.exec(processedText);
              if (match) {
                endIndex = match.index;
              }
            } catch (e) {
              showStatus(`Invalid End RegEx: ${e.message}`, 'error');
              throw e;
            }
          } else {
            endIndex = processedText.indexOf(endMarker);
          }
          if (endIndex !== -1) {
            processedText = processedText.substring(0, endIndex);
          }
        }
        
        const trimmedText = processedText.trim();
        const trimmedLength = trimmedText.length;
        
        lastTrimmedText = trimmedText;
        
        return {
          text: trimmedText,
          originalLength,
          trimmedLength
        };
      }

      function chunkText() {
        hideStatus();
        
        const chapterContentEl = document.getElementById('chapterContent');
        const startMarker = document.getElementById('startMarker').value;
        const useStartRegex = document.getElementById('useStartRegex').checked;
        const endMarker = document.getElementById('endMarker').value;
        const useEndRegex = document.getElementById('useEndRegex').checked;
        const maxChars = parseInt(document.getElementById('maxChars').value) || 1800;
        
        if (!chapterContentEl.value.trim()) {
          showStatus('Please enter some text first', 'error');
          return;
        }

        try {
          const { text: processedText, originalLength, trimmedLength } = trimText(
            chapterContentEl.value,
            startMarker,
            useStartRegex,
            endMarker,
            useEndRegex
          );
          
          chapterContentEl.value = processedText;
          updateCharCount();
          updateTranslationWarning(trimmedLength);

          const paragraphs = processedText.split('\n');
          let chunks = [];
          let currentChunk = '';

          for (const paragraph of paragraphs) {
            const trimmedParagraph = paragraph.trim();
            if (trimmedParagraph.length === 0) continue;

            if (currentChunk.length > 0 && 
                currentChunk.length + trimmedParagraph.length + 1 > maxChars) {
              chunks.push(currentChunk);
              currentChunk = '';
            }
            currentChunk += (currentChunk ? '\n' : '') + trimmedParagraph;
          }

          if (currentChunk) {
            chunks.push(currentChunk);
          }

          const chunkedTextContainer = document.getElementById('chunkedText
