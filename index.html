<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EPUB Text Chunker</title>
    <script src="./script/jszip.min.js"></script>
    <script src="./script/epub.min.js"></script>
    <style>
      body {
        font-family: 'Roboto', sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f7f6;
        color: #333;
      }

      h1 {
        text-align: center;
        color: #007bff;
        margin-bottom: 30px;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
        background-color: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .input-group {
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
      }

      .input-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: #555;
      }

      input[type='file'],
      input[type='number'],
      select,
      textarea {
        padding: 10px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 15px;
        width: 100%;
        box-sizing: border-box;
        font-family: 'Roboto', sans-serif;
      }

      textarea {
        min-height: 100px;
        resize: vertical;
      }

      #tocContainer {
        margin-bottom: 20px;
        max-height: 250px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 4px;
        background-color: #f9f9f9;
      }

      #tocContainer label {
        font-weight: bold;
        display: block;
        margin-bottom: 10px;
      }

      #tocList {
        list-style: none;
        padding-left: 0;
      }

      #tocList ul {
        padding-left: 20px;
        list-style-type: circle;
      }

      #tocList li {
        cursor: pointer;
        margin-bottom: 6px;
        padding: 4px 8px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
      }

      #tocList li:hover {
        background-color: #e9ecef;
      }

      #tocList li.selected {
        background-color: #007bff;
        color: white;
      }

      #charCount {
        font-size: 13px;
        color: #555;
        text-align: right;
        margin-top: 5px;
      }

      .button-group {
        text-align: center;
        margin-top: 30px;
      }

      .button {
        padding: 12px 25px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 17px;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }

      .button:hover {
        background-color: #218838;
      }

      .button:active {
        transform: scale(0.98);
      }

      #chunkedTextContainer {
        margin-top: 40px;
        border-top: 1px solid #eee;
        padding-top: 20px;
      }

      .chunk-container {
        margin-bottom: 25px;
        padding: 15px;
        display: flex;
        align-items: center;
        background-color: #fcfcfc;
      }

      .chunk-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .chunk-title {
        font-weight: bold;
        font-size: 16px;
        margin-right: 10px;
      }

      .copy-button {
        padding: 5px 8px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        font-size: 14px;
        transition: background-color 0.2s ease;
        margin-left: 8px;
      }

      .copy-button:hover {
        background-color: #0056b3;
      }

      .copy-button.green {
        background-color: #28a745;
      }

      .copy-button .tick {
        display: none;
        margin-left: 5px;
        font-size: 16px;
      }

      .copy-button.green .tick {
        display: inline-block;
      }

      .chunk-textarea {
        width: 100%;
        height: 120px;
        padding: 10px;
        font-size: 14px;
        line-height: 1.5;
        border: 1px solid #ddd;
        border-radius: 4px;
        resize: vertical;
        overflow-y: auto;
        background-color: #fff;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <h1>EPUB Text Chunker</h1>
      <div class="input-group">
        <label for="epubInput">Select an EPUB or txt file:</label>
        <input type="file" id="epubInput" accept=".epub, .txt" />
      </div>

      <div id="tocContainer">
        <label>Table of Contents:</label>
        <ul id="tocList"></ul>
      </div>

      <div class="input-group">
        <label for="chapterContent">Text Content:</label>
        <textarea
          id="chapterContent"
          placeholder="Paste text or load from file..."
        ></textarea>
        <div id="charCount">Total characters: 0</div>
      </div>

      <div class="input-group">
        <label for="maxChars">Max characters per chunk:</label>
        <input type="number" id="maxChars" value="1800" />
      </div>

      <div class="input-group">
        <label for="formatSelect">Format text:</label>
        <select id="formatSelect">
          <option value="as-is">Show text as is</option>
          <option value="pretty">Pretty</option>
        </select>
      </div>

      <div class="input-group">
        <label for="addToTop">Add to top of each chunk:</label>
        <textarea
          id="addToTop"
          placeholder="Text to add to the top of each chunk (use $X for part number, $Y for total parts)..."
        ></textarea>
      </div>

      <div class="input-group">
        <label for="addToBottom">Add to bottom of each chunk:</label>
        <textarea
          id="addToBottom"
          placeholder="Text to add to the bottom of each chunk (use $X for part number, $Y for total parts)..."
        ></textarea>
      </div>

      <button
        onclick="chunkText()"
        style="
          padding: 10px 20px;
          background-color: #28a745;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 16px;
        "
      >
        Split Text
      </button>

      <div id="chunkedTextContainer"></div>
    </div>

    <script>
      let book;
      let lastClickedButton = null;
      let originalText = null; // Store the original unformatted text

      function updateButtonState(button) {
        if (lastClickedButton && lastClickedButton !== button) {
          lastClickedButton.classList.remove('green');
          lastClickedButton.querySelector('.tick').style.display = 'none';
        }

        button.classList.add('green');
        button.querySelector('.tick').style.display = 'inline-block';
        lastClickedButton = button;
      }

      function updateCharCount() {
        const text = document.getElementById('chapterContent').value;
        document.getElementById(
          'charCount',
        ).textContent = `Total characters: ${text.length}`;
      }

      document.addEventListener('DOMContentLoaded', () => {
        const maxCharsInput = document.getElementById('maxChars');
        const addToTopInput = document.getElementById('addToTop');
        const addToBottomInput = document.getElementById('addToBottom');
        const formatSelect = document.getElementById('formatSelect');
        const chapterContentTextArea =
          document.getElementById('chapterContent');

        maxCharsInput.value = localStorage.getItem('maxChars') || '1800';
        const addToTopDefault = ''; // Keep this field blank by default
        addToTopInput.value =
          localStorage.getItem('addToTop') || addToTopDefault;
        const addToBottomDefault = '';
        addToBottomInput.value =
          localStorage.getItem('addToBottom') || addToBottomDefault;

        const savedFormat = localStorage.getItem('formatSelect');
        if (savedFormat) {
          formatSelect.value = savedFormat;
        } else {
          formatSelect.value = 'pretty';
        }

        maxCharsInput.addEventListener('input', () => {
          localStorage.setItem('maxChars', maxCharsInput.value);
        });

        addToTopInput.addEventListener('input', () => {
          localStorage.setItem('addToTop', addToTopInput.value);
        });

        addToBottomInput.addEventListener('input', () => {
          localStorage.setItem('addToBottom', addToBottomInput.value);
        });

        formatSelect.addEventListener('change', () => {
          localStorage.setItem('formatSelect', formatSelect.value);
          formatText();
        });

        chapterContentTextArea.addEventListener('input', updateCharCount);

        // Initial format and char count on load
        formatText();
        updateCharCount();
      });

      document
        .getElementById('epubInput')
        .addEventListener('change', async function (event) {
          const file = event.target.files[0];
          const fileName = file.name.toLowerCase();
          try {
            if (fileName.endsWith('.epub')) {
              book = ePub(file);
              const toc = await book.loaded.navigation;
              const tocList = document.getElementById('tocList');
              tocList.innerHTML = '';

              function addTocItems(items, parentElement) {
                items.forEach((item) => {
                  const li = document.createElement('li');
                  li.textContent = item.label.trim();
                  li.dataset.href = item.href;
                  li.addEventListener('click', loadChapter);
                  parentElement.appendChild(li);

                  if (item.subitems && item.subitems.length > 0) {
                    const ul = document.createElement('ul');
                    addTocItems(item.subitems, ul);
                    li.appendChild(ul);
                  }
                });
              }

              addTocItems(toc, tocList);
            } else if (fileName.endsWith('.txt')) {
              const reader = new FileReader();
              reader.onload = function (e) {
                originalText = e.target.result;
                document.getElementById('chapterContent').value = originalText;
                formatText();
                updateCharCount();
              };
              reader.readAsText(file);
            } else {
              alert(
                'Unsupported file type. Please upload .epub or .txt files.',
              );
            }
          } catch (error) {
            console.error('Error loading file:', error);
            alert('Failed to load file. See console for details.');
          }
        });

      async function loadChapter(event) {
        const tocListItems = document.querySelectorAll('#tocList li');
        tocListItems.forEach((item) => item.classList.remove('selected'));
        event.target.classList.add('selected');

        const selectedHref = event.target.dataset.href;
        try {
          const chapter = await book.load(selectedHref);
          originalText = extractText(chapter);
          document.getElementById('chapterContent').value = originalText;
          formatText();
          updateCharCount();
        } catch (error) {
          console.error('Error loading chapter:', error);
          alert('Failed to load chapter. See console for details.');
        }
      }

      function extractText(chapterDocument) {
        return chapterDocument.body.innerText.trim();
      }

      function chunkText() {
        const text = document.getElementById('chapterContent').value;
        const maxChars = parseInt(document.getElementById('maxChars').value);
        const addToTop = document.getElementById('addToTop').value.trim();
        const addToBottom = document
          .getElementById('addToBottom')
          .value.trim();

        const paragraphs = text.split('\n');
        const chunks = [];
        let currentChunk = '';

        for (const paragraph of paragraphs) {
          // Check if adding the paragraph plus newline would exceed the max characters
          if (currentChunk.length + paragraph.length + 2 <= maxChars) {
            // +2 for newline
            currentChunk += paragraph + '\n';
          } else {
            // Push the current chunk (trimmed to remove trailing newline from loop)
            chunks.push(currentChunk.trim());
            // Start a new chunk with the current paragraph plus a newline
            currentChunk = paragraph + '\n';
          }
        }

        // Push the last chunk if it's not empty
        if (currentChunk.trim()) {
          chunks.push(currentChunk.trim());
        }

        const totalChunks = chunks.length;
        const chunkedTextContainer = document.getElementById(
          'chunkedTextContainer',
        );
        chunkedTextContainer.innerHTML = '';

        const digits = String(totalChunks).length;

        chunks.forEach((chunk, index) => {
          const partNumber = String(index + 1).padStart(digits, '0');
          let finalChunk =
            (
              addToTop.replace('$X', partNumber).replace('$Y', totalChunks) +
              '\n\n' +
              chunk +
              '\n\n' +
              addToBottom.replace('$X', partNumber).replace('$Y', totalChunks)
            ).trim() + '\n'; // Add a newline at the end for easier copying

          const chunkContainer = document.createElement('div');
          chunkContainer.classList.add('chunk-container');

          const chunkHeader = document.createElement('div');
          chunkHeader.classList.add('chunk-header');

          const chunkTitle = document.createElement('div');
          chunkTitle.classList.add('chunk-title');
          chunkTitle.textContent = `Part ${partNumber}`;

          const copyButton = document.createElement('button');
          copyButton.classList.add('copy-button');
          copyButton.innerHTML =
            'Copy to Clipboard<span class="tick">✔️</span>';
          copyButton.addEventListener('click', function () {
            copyToClipboard(chunkTextarea.value);
            updateButtonState(copyButton);
          });

          chunkHeader.appendChild(chunkTitle);

          const chunkTextarea = document.createElement('textarea');
          chunkTextarea.classList.add('chunk-textarea');
          chunkTextarea.value = finalChunk;
          chunkTextarea.readOnly = true;

          chunkContainer.appendChild(chunkHeader);
          chunkContainer.appendChild(chunkTextarea);
          chunkContainer.appendChild(copyButton);
          chunkedTextContainer.appendChild(chunkContainer);
        });
      }

      function copyToClipboard(text) {
        const hiddenInput = document.createElement('textarea');
        hiddenInput.value = text;
        document.body.appendChild(hiddenInput);
        hiddenInput.select();
        try {
          document.execCommand('copy');
        } catch (err) {
          console.error('Copy to clipboard failed:', err);
        }

        document.body.removeChild(hiddenInput);
      }

      function formatText() {
        const formatSelect = document.getElementById('formatSelect');
        const textArea = document.getElementById('chapterContent');

        if (originalText === null && textArea.value) {
          // If originalText is null but textarea has content (e.g. pasted)
          originalText = textArea.value;
        }

        if (formatSelect.value === 'pretty' && originalText) {
          const paragraphs = originalText.split('\n');
          const formattedText = paragraphs
            .map((p) => p.trim())
            .filter((p) => p)
            .join('\n\n');
          textArea.value = formattedText;
        } else if (originalText) {
          // "as-is" or originalText is not yet set but we have it
          textArea.value = originalText;
        }
        // If originalText is null and textarea is empty, do nothing.
        updateCharCount(); // Update char count after formatting
      }
    </script>
  </body>
</html>