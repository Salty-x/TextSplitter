<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Text Cleaner & Chunker</title>
    <style>
      body {
        font-family: 'Roboto', sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f7f6;
        color: #333;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
        background-color: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #007bff;
        margin-bottom: 30px;
      }
      .input-group {
        margin-bottom: 20px;
      }
      .input-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 8px;
      }
      .input-row label {
        font-weight: bold;
        color: #555;
      }
      input[type='number'],
      input[type='text'],
      textarea {
        padding: 10px 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 15px;
        width: 100%;
        box-sizing: border-box;
        font-family: 'Roboto', sans-serif;
      }
      textarea {
        min-height: 140px;
        resize: vertical;
      }
      #charCount {
        font-size: 13px;
        color: #555;
        text-align: right;
        margin-top: 5px;
      }
      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .btn {
        padding: 10px 14px;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 15px;
        transition: filter 0.15s ease;
        white-space: nowrap;
      }
      .btn:hover {
        filter: brightness(0.95);
      }
      .btn-paste {
        background-color: #6f42c1;
      }
      .btn-split {
        background-color: #28a745;
      }

      #chunkedTextContainer {
        margin-top: 25px;
        border-top: 1px solid #eee;
        padding-top: 20px;
      }
      .chunk-container {
        margin-bottom: 20px;
        background-color: #fcfcfc;
        border: 1px solid #eee;
        border-radius: 4px;
        padding: 15px;
      }
      .chunk-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        gap: 10px;
      }
      .chunk-title {
        font-weight: bold;
        font-size: 16px;
      }
      .copy-button {
        padding: 6px 10px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        flex-shrink: 0;
      }
      .copy-button.copied {
        background-color: #218838;
      }
      .chunk-textarea {
        width: 100%;
        height: 110px;
        padding: 10px;
        font-size: 14px;
        line-height: 1.5;
        border: 1px solid #ddd;
        border-radius: 4px;
        resize: vertical;
        background-color: #fff;
      }
      .trim-options {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }
      .trim-options .input-group {
        flex-grow: 1;
        min-width: 250px;
      }
      .regex-option {
        display: flex;
        align-items: center;
        margin-top: 8px;
        font-size: 14px;
        color: #555;
        gap: 8px;
      }
      .regex-option input {
        width: auto;
        margin: 0;
      }
      .hint {
        font-size: 12px;
        color: #666;
        margin-top: 6px;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <h1>Text Cleaner & Chunker</h1>

      <div class="input-group">
        <div class="input-row">
          <label for="chapterContent">Text Content:</label>
          <div class="actions">
            <button class="btn btn-paste" id="pasteBtn" type="button">Paste & Split</button>
            <button class="btn btn-split" id="splitBtn" type="button">Clean and Split Text</button>
          </div>
        </div>

        <textarea id="chapterContent" placeholder="Paste the chapter text here..."></textarea>
        <div id="charCount">Total characters: 0</div>
        <div class="hint">
          Tip: If the Paste button fails in your browser on a local file, it will ask you to paste manually.
        </div>
      </div>

      <div class="trim-options">
        <div class="input-group">
          <label for="startMarker">Start content at this text/pattern:</label>
          <input type="text" id="startMarker" placeholder="e.g., 第\\d+章[\\s\\S]*" />
          <div class="regex-option">
            <input type="checkbox" id="useStartRegex" />
            <label for="useStartRegex">Use RegEx</label>
          </div>
        </div>

        <div class="input-group">
          <label for="endMarker">End content before this text/pattern:</label>
          <input type="text" id="endMarker" placeholder="e.g., \\(本章完\\)" />
          <div class="regex-option">
            <input type="checkbox" id="useEndRegex" />
            <label for="useEndRegex">Use RegEx</label>
          </div>
        </div>
      </div>

      <div class="input-group">
        <label for="maxChars">Max characters per chunk:</label>
        <input type="number" id="maxChars" value="1800" />
      </div>

      <div id="chunkedTextContainer"></div>
    </div>

    <script>
      let lastClickedCopyButton = null;

      function copyToClipboard(text, button) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            if (lastClickedCopyButton && lastClickedCopyButton !== button) {
              lastClickedCopyButton.classList.remove('copied');
              lastClickedCopyButton.textContent = 'Copy';
            }
            button.textContent = 'Copied! ✔';
            button.classList.add('copied');
            lastClickedCopyButton = button;
          })
          .catch((err) => console.error('Failed to copy text:', err));
      }

      function updateCharCount() {
        const text = document.getElementById('chapterContent').value;
        document.getElementById('charCount').textContent = `Total characters: ${text.length}`;
      }

      function getStartIndex(text, marker, useRegex) {
        if (!marker) return -1;
        if (useRegex) {
          try {
            const regex = new RegExp(marker);
            const match = regex.exec(text);
            return match ? match.index : -1; // keep the matched text
          } catch (e) {
            alert('Invalid Start RegEx: ' + e.message);
            return null; // signal error
          }
        }
        return text.indexOf(marker);
      }

      function getEndIndex(text, marker, useRegex) {
        if (!marker) return -1;
        if (useRegex) {
          try {
            const regex = new RegExp(marker);
            const match = regex.exec(text);
            return match ? match.index : -1; // end BEFORE matched text
          } catch (e) {
            alert('Invalid End RegEx: ' + e.message);
            return null; // signal error
          }
        }
        return text.indexOf(marker);
      }

      function chunkText() {
        const chapterContentEl = document.getElementById('chapterContent');
        const startMarker = document.getElementById('startMarker').value;
        const useStartRegex = document.getElementById('useStartRegex').checked;
        const endMarker = document.getElementById('endMarker').value;
        const useEndRegex = document.getElementById('useEndRegex').checked;

        let processedText = chapterContentEl.value;

        // Trim start
        const startIndex = getStartIndex(processedText, startMarker, useStartRegex);
        if (startIndex === null) return; // regex error
        if (startIndex !== -1) processedText = processedText.substring(startIndex);

        // Trim end
        const endIndex = getEndIndex(processedText, endMarker, useEndRegex);
        if (endIndex === null) return; // regex error
        if (endIndex !== -1) processedText = processedText.substring(0, endIndex);

        processedText = processedText.trim();
        chapterContentEl.value = processedText;
        updateCharCount();

        // Split into chunks
        const maxChars = parseInt(document.getElementById('maxChars').value, 10) || 1800;
        const chunkedTextContainer = document.getElementById('chunkedTextContainer');

        const paragraphs = processedText.split('\n');
        let chunks = [];
        let currentChunk = '';

        for (const paragraph of paragraphs) {
          const trimmed = paragraph.trim();
          if (!trimmed) continue;

          if (currentChunk && currentChunk.length + trimmed.length + 1 > maxChars) {
            chunks.push(currentChunk);
            currentChunk = '';
          }
          currentChunk += (currentChunk ? '\n' : '') + trimmed;
        }
        if (currentChunk) chunks.push(currentChunk);

        chunkedTextContainer.innerHTML = '';
        lastClickedCopyButton = null;

        chunks.forEach((chunk, index) => {
          const chunkContainer = document.createElement('div');
          chunkContainer.classList.add('chunk-container');

          const chunkHeader = document.createElement('div');
          chunkHeader.classList.add('chunk-header');

          const chunkTitle = document.createElement('div');
          chunkTitle.classList.add('chunk-title');
          chunkTitle.textContent = `Part ${index + 1} of ${chunks.length}`;

          const copyButton = document.createElement('button');
          copyButton.classList.add('copy-button');
          copyButton.textContent = 'Copy';

          const chunkTextarea = document.createElement('textarea');
          chunkTextarea.classList.add('chunk-textarea');
          chunkTextarea.value = chunk;

          copyButton.addEventListener('click', () => copyToClipboard(chunkTextarea.value, copyButton));

          chunkHeader.appendChild(chunkTitle);
          chunkHeader.appendChild(copyButton);
          chunkContainer.appendChild(chunkHeader);
          chunkContainer.appendChild(chunkTextarea);

          chunkedTextContainer.appendChild(chunkContainer);
        });
      }

      async function pasteAndSplit() {
        const textarea = document.getElementById('chapterContent');

        // Try modern clipboard read (may require HTTPS / localhost)
        try {
          if (navigator.clipboard && navigator.clipboard.readText) {
            const text = await navigator.clipboard.readText();
            textarea.value = text || '';
          } else {
            throw new Error('Clipboard API not available');
          }
        } catch (err) {
          // Fallback: manual paste prompt
          const manual = prompt('Clipboard read blocked by your browser.\nPaste your text here:');
          if (manual === null) return; // cancelled
          textarea.value = manual;
        }

        updateCharCount();
        chunkText(); // auto split after paste button
      }

      document.addEventListener('DOMContentLoaded', () => {
        // ✅ Preset regex markers on every load
        document.getElementById('startMarker').value = '第\\d+章[\\s\\S]*';
        document.getElementById('endMarker').value = '\\(本章完\\)';
        document.getElementById('useStartRegex').checked = true;
        document.getElementById('useEndRegex').checked = true;

        // Buttons
        document.getElementById('pasteBtn').addEventListener('click', pasteAndSplit);
        document.getElementById('splitBtn').addEventListener('click', chunkText);

        // Auto split when user manually pastes into textarea
        const textarea = document.getElementById('chapterContent');
        textarea.addEventListener('input', updateCharCount);
        textarea.addEventListener('paste', () => {
          // wait for paste to apply, then split
          setTimeout(() => {
            updateCharCount();
            chunkText();
          }, 0);
        });

        updateCharCount();
      });
    </script>
  </body>
</html>
